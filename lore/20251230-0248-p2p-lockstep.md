# P2P Lockstep Networking Implementation

## Overview

Refactored from server-authoritative to P2P lockstep architecture. Game simulation runs entirely on clients, server only handles lobby/matchmaking/signaling.

## Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                    P2P LOCKSTEP ARCHITECTURE                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Client A                                        Client B        │
│  ┌──────────────────┐                    ┌──────────────────┐   │
│  │ Deterministic    │◄══════════════════►│ Deterministic    │   │
│  │ Simulation       │   WebRTC P2P       │ Simulation       │   │
│  │ (TypeScript)     │   (inputs only)    │ (TypeScript)     │   │
│  └────────┬─────────┘                    └────────┬─────────┘   │
│           │                                       │              │
│           │  WebSocket (signaling only)           │              │
│           └───────────────┬───────────────────────┘              │
│                           ▼                                      │
│                 ┌─────────────────┐                              │
│                 │  Phoenix Server │                              │
│                 │  - Lobby        │                              │
│                 │  - Matchmaking  │                              │
│                 │  - WebRTC SDP   │                              │
│                 └─────────────────┘                              │
└─────────────────────────────────────────────────────────────────┘
```

## How Lockstep Works

```
Frame Timeline (3-frame input delay):

Client A:  [capture]─────────────────────[simulate]
             F0                               F3
              │                                │
              └──► send input for F3 ─────────►│
                                               │
Client B:  [capture]─────────────────────[simulate]
             F0                               F3
              │                                │
              └──► send input for F3 ─────────►│

Both clients wait for ALL inputs before simulating frame.
Input delay hides network latency.
```

**Key Points:**
1. Players capture input at frame N
2. Input is tagged for frame N+delay (e.g., N+3)
3. Input sent to all peers immediately
4. Simulation waits until ALL peer inputs for frame received
5. Simulation advances with all inputs applied in deterministic order

## Files Created/Modified

### Server (Simplified)

**`lib/astranyx/game/lobby.ex`** - Room management only
- Create/join/leave rooms
- Track players and host
- Coordinate game start
- No game simulation

**`lib/astranyx_web/channels/room_channel.ex`** - Lobby channel
- Room join/leave events
- Game start coordination
- Player presence

**`lib/astranyx_web/channels/signaling_channel.ex`** - WebRTC signaling
- SDP offer/answer relay
- ICE candidate relay
- Peer presence (joined/left)

**Removed:**
- `lib/astranyx/game/room.ex` (had game loop)
- `lib/astranyx/game/state.ex` (had player state)
- `lib/astranyx/game/physics.ex` (had physics simulation)

### Client (Enhanced)

**`src/network/LockstepNetcode.ts`** - Core lockstep implementation
```typescript
interface FrameInput {
  frame: number
  playerId: string
  input: PlayerInput
  checksum?: number
}

class LockstepNetcode {
  // Input delay (default 3 frames = 50ms at 60fps)
  inputDelay: number

  // Frame tracking
  currentFrame: number
  confirmedFrame: number

  // Input storage: frame -> player_id -> input
  inputBuffer: Map<number, Map<string, FrameInput>>

  // Core method: returns true if simulation should advance
  tick(localInput: PlayerInput): boolean
}
```

**`src/network/P2PManager.ts`** - WebRTC peer connections
- Creates RTCPeerConnection per peer
- Uses DataChannel (unreliable, unordered) for inputs
- Handles SDP/ICE exchange via Phoenix signaling

**`src/game/Simulation.ts`** - Deterministic game simulation
```typescript
// CRITICAL: Must be 100% deterministic
// Rules:
// - No Math.random() - use SeededRandom
// - No Date.now() - use frame counter
// - Fixed-point math for positions
// - Consistent iteration order

class Simulation {
  tick(inputs: Map<string, PlayerInput>): void
  getState(): GameState
  getChecksum(): number  // For desync detection
}
```

**`src/game/Game.ts`** - Updated to support both modes
- Single player: immediate simulation
- Multiplayer: lockstep via netcode

## Determinism Requirements

### Fixed-Point Math
```typescript
const FP_SHIFT = 16
const FP_ONE = 1 << FP_SHIFT  // 65536

// Position stored as fixed-point (16.16)
entity.x = toFixed(-200)  // -200 * 65536

// Multiplication
function mulFixed(a: number, b: number): number {
  return Math.round((a * b) / FP_ONE)
}
```

### Seeded PRNG
```typescript
// xorshift32 - same sequence on all clients
class SeededRandom {
  next(): number {
    let x = this.state
    x ^= x << 13
    x ^= x >>> 17
    x ^= x << 5
    this.state = x >>> 0
    return (x >>> 0) / 0xffffffff
  }
}
```

### Consistent Ordering
- Entities stored in array, not object/map
- Players processed in order by player index
- Collision checks iterate in consistent order

## Desync Detection

Each frame, simulation generates checksum:
```typescript
getChecksum(): number {
  let hash = this.state.frame
  for (const entity of this.state.entities) {
    hash ^= entity.id
    hash ^= entity.x
    hash ^= entity.y
    hash ^= entity.health
    hash = (hash * 31) >>> 0
  }
  return hash
}
```

Clients can exchange checksums to detect desync early.

## Connection Flow

1. **Lobby Phase**
   - Client A creates room (becomes host)
   - Client B joins room via Phoenix WebSocket
   - Both join signaling channel

2. **WebRTC Setup**
   - Higher player ID initiates connection
   - Exchange SDP via signaling channel
   - Exchange ICE candidates
   - DataChannel opens

3. **Game Start**
   - Host sends `start_game` to server
   - Server broadcasts `game_starting` with player order
   - All clients initialize Simulation with same seed
   - All clients start LockstepNetcode

4. **Gameplay**
   - Each tick: capture input, tag for future frame, send to peers
   - Wait for all peer inputs
   - Advance simulation deterministically

## Ports (Updated)

| Service | Port |
|---------|------|
| Vite (client) | 4100 |
| Phoenix (server) | 4200 |

## Running

```bash
# Terminal 1: Phoenix server
cd server
source ~/.asdf/asdf.sh
mix phx.server

# Terminal 2: Vite client
cd client
bun run dev
```

Open http://localhost:4100 - starts in single-player mode by default.

## Next Steps

1. Add lobby UI for creating/joining rooms
2. Implement full connection flow
3. Add desync detection with checksum comparison
4. Add input delay configuration UI
5. Implement rollback netcode for lower-latency feel (optional)

## Design Influences

- **GGPO** - Rollback netcode for fighting games (future enhancement)
- **Lockstep** - Classic RTS netcode (Age of Empires, StarCraft)
- **Fighting games** - Input delay approach (Street Fighter, Tekken)

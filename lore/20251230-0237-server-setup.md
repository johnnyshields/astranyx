# Astranyx Server Setup

## Overview

Phoenix server setup for multiplayer game networking with hybrid WebSocket + WebRTC architecture.

## Architecture Decision: Hybrid Networking

```
┌─────────────────────────────────────────────────────────────────┐
│                         CLIENT A                                 │
├─────────────────────────────────────────────────────────────────┤
│  Phoenix WebSocket          │  WebRTC DataChannel               │
│  (Lobby, Rooms, Signaling)  │  (Game Input/State @ 60Hz)        │
└──────────────┬──────────────┴────────────────┬──────────────────┘
               │                               │
               ▼                               │
┌──────────────────────────────┐               │
│       PHOENIX SERVER         │               │
│  - Room management           │               │
│  - Matchmaking               │               │
│  - WebRTC signaling          │◄──────────────┤ (TURN if needed)
│  - Chat/leaderboards         │               │
└──────────────────────────────┘               │
               │                               │
               ▼                               ▼
┌─────────────────────────────────────────────────────────────────┐
│                         CLIENT B                                 │
└─────────────────────────────────────────────────────────────────┘
```

**WebSocket (Phoenix Channels)** - Reliable, ordered:
- Lobby/matchmaking
- Room management
- WebRTC signaling (SDP/ICE exchange)
- Chat, leaderboards

**WebRTC DataChannel** - Low latency, unreliable mode:
- Real-time game input/state (60Hz)
- ~5-20ms latency vs ~50-100ms WebSocket
- No head-of-line blocking

## Tech Stack

| Component | Technology | Version |
|-----------|------------|---------|
| Runtime | Erlang/OTP | 28.3 |
| Language | Elixir | 1.19.4 |
| Framework | Phoenix | 1.8.3 |
| Version Manager | asdf | 0.15.0 |

## Server Structure

```
server/
├── lib/
│   ├── astranyx/
│   │   ├── application.ex     # OTP app supervisor
│   │   ├── game/
│   │   │   ├── room.ex        # Game room GenServer (60Hz loop)
│   │   │   ├── state.ex       # Game state manipulation
│   │   │   └── physics.ex     # Physics simulation
│   │   └── astranyx.ex
│   └── astranyx_web/
│       ├── channels/
│       │   ├── game_socket.ex       # Main socket
│       │   ├── room_channel.ex      # Game room channel
│       │   └── signaling_channel.ex # WebRTC signaling
│       ├── endpoint.ex
│       └── router.ex
├── config/
│   ├── config.exs
│   ├── dev.exs              # Port 4200
│   └── prod.exs
└── mix.exs
```

## Key Components

### GameSocket (`/socket`)
Main WebSocket connection point. Handles:
- Player authentication (assigns player_id)
- Routing to channels

### RoomChannel (`room:*`)
Game room management:
- Join/leave rooms
- Receive game state broadcasts
- Send player inputs
- Handle ping/pong for latency

### SignalingChannel (`signaling:*`)
WebRTC connection establishment:
- Relay SDP offers/answers
- Relay ICE candidates
- Peer presence (joined/left)

### Room GenServer
Per-room game state:
- 60Hz fixed timestep game loop
- Player entity management
- Physics simulation
- State broadcasting via PubSub

## Ports

| Service | Port |
|---------|------|
| Vite (client) | 4100 |
| Phoenix (server) | 4200 |

## Running

```bash
# Terminal 1: Start Phoenix server
cd server
source ~/.asdf/asdf.sh
mix phx.server

# Terminal 2: Start Vite client
cd client
bun run dev
```

## Game Loop Architecture

The server runs at 60Hz fixed timestep:

```elixir
@tick_rate 60
@tick_ms div(1000, @tick_rate)  # ~16.67ms

def handle_info(:tick, state) do
  state =
    state
    |> process_inputs()      # Apply buffered player inputs
    |> Physics.update(dt)    # Run physics simulation
    |> Map.update!(:tick, &(&1 + 1))

  broadcast_state(state)     # Send to all players
  schedule_tick()            # Schedule next tick

  {:noreply, state}
end
```

## Client-Server Protocol

### Input Message (Client → Server)
```json
{
  "tick": 1234,
  "input": {
    "up": true,
    "down": false,
    "left": false,
    "right": true,
    "fire": true,
    "special": false
  }
}
```

### State Message (Server → Client)
```json
{
  "tick": 1235,
  "timestamp": 1704067200000,
  "entities": [
    {
      "id": "player_abc123",
      "type": "player",
      "x": -150.5,
      "y": 42.3,
      "vx": 120.0,
      "vy": 0.0,
      "rotation": 0.05,
      "health": 100
    }
  ],
  "events": []
}
```

## Design Influences

- **R-Type**: Force pod system
- **Einhänder**: 2.5D aesthetic, weapon pickups
- **Gradius**: Option drones, power-up bar
- **Ikaruga**: Polarity switching, chain combos
- **Radiant Silvergun**: Weapon chaining, scoring depth
- **Bruno Simon**: Polished WebGL aesthetic

## Next Steps

1. Add Phoenix client library to frontend
2. Implement channel connection in client
3. Wire up player input sending
4. Add state interpolation for smooth rendering
5. Implement WebRTC DataChannel upgrade for game traffic

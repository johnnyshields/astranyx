# State Synchronization for P2P Multiplayer

## Summary

Implemented periodic state synchronization to correct desync in the P2P lockstep multiplayer system. The host (player index 0) broadcasts authoritative game state to non-host players, with pending local events preserved and re-applied after sync.

## Problem

The hybrid lockstep + owner-authoritative events system had a fundamental timing issue:
- Events generated locally were applied immediately
- The same events arrived at remote clients 3+ frames later (input delay)
- This caused simulation state to diverge, especially with item drops and pickups

## Solution

### Two-Tier Sync Strategy

1. **Periodic Sync (every 5 seconds)**: Host broadcasts full state every 300 frames to correct accumulated drift
2. **Immediate Sync on Desync**: When checksum mismatch is detected, host immediately broadcasts state

### Pending Events Buffer

Non-host players buffer their local events (pickups, damage, etc.). When state sync arrives:
1. Apply authoritative state from host
2. Re-apply pending local events to preserve player's recent actions
3. Clear the pending events buffer

## Key Changes

### `LockstepNetcode.ts`
- Added `pendingLocalEvents: GameEvent[]` buffer
- Added `desyncDetected` flag for immediate sync trigger
- `shouldSendStateSync()` returns true on desync OR every 300 frames
- `receiveStateSync()` passes pending events to handler for re-application
- Changed default `stateSyncInterval` from 60 to 300 frames (5 seconds)

### `Simulation.ts`
- Added `SerializedState` interface for network-safe state
- Added `serializeState()` to export game state (converts Sets to arrays)
- Added `applyState()` to import authoritative state from host

### `Game.ts`
- State sync handler applies state then re-applies pending local events
- Calls `clearDesyncFlag()` after broadcast

## Message Flow

```
Host (Player 0)                    Non-Host (Player 1)
     |                                    |
     |--- FrameInput (with events) ------>|
     |<--- FrameInput (with events) ------|
     |                                    |
     | [Every 300 frames OR on desync]    |
     |--- StateSyncMessage -------------->|
     |                                    | [Apply state]
     |                                    | [Re-apply pending events]
     |                                    |
```

## Data Structures

```typescript
interface StateSyncMessage {
  type: 'state_sync'
  frame: number
  state: SerializedState
  checksum: number
}

interface SerializedState {
  frame: number
  rngSeed: number
  players: Player[]
  bullets: Array<...>  // Sets converted to arrays
  beams: Array<...>
  missiles: Missile[]
  enemies: Enemy[]
  boss: Boss | null
  powerups: Powerup[]
  weaponDrops: WeaponDrop[]
  nextId: number
  score: number
  multiplier: number
  wave: number
  waveTimer: number
  bossActive: boolean
  screenShake: number
  gameOver: boolean
}
```

## Configuration

- `stateSyncInterval`: Frames between periodic syncs (default: 300 = 5 seconds)
- Checksum comparison every 30 frames for desync detection
- Host is determined by player order index (index 0 = host)

## Trade-offs

- **Bandwidth**: Full state sync is larger than input messages, but only every 5 seconds
- **Visual Jump**: State sync may cause slight visual discontinuity
- **Event Re-application**: Pending events might already be in host's state, causing duplicates (acceptable for most events)

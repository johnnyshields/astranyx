# Game Modes

Astranyx supports multiple game modes that can be mixed within a single world. Each segment in a world can use a different mode, creating variety in gameplay while maintaining the deterministic lockstep netcode.

## Mode Overview

| Mode | Camera | Player Movement | Aiming | Example |
|------|--------|-----------------|--------|---------|
| SideScroll | Fixed/tracking | 2D (UP/DOWN/LEFT/RIGHT) | Auto-forward | R-Type, Gradius |
| OnRails | Follows path | Dodge left/right | Auto-forward | Starfox |
| Turret | Follows path | Locked to path | Mouse aim | Rail shooters |
| FirstPerson | At player eye | 3D WASD | Mouse aim | DOOM, Quake |
| FreeFlight | Chase camera | Full 3D flight | Ship direction | Rogue Squadron |

## Mode Details

### SideScroll

Classic 2D shoot-em-up mode. Camera is fixed or gently tracks player X position.

**Controls:**
- Arrow keys / WASD: Move in 2D plane (X/Y)
- Space/Z: Fire (auto-aimed forward)
- X: Special weapon
- C: Focus mode (slower, precise movement)

**Camera:**
- Position: Fixed Z distance from play field
- Tracking: Optional smooth follow on X axis
- Scroll: Level auto-scrolls, pushing player forward

**Use cases:** Space approach sections, classic shmup segments

**Segment example:** `1_approach.rhai`
```rhai
mode: "side-scroll",
scroll: #{ enabled: true, direction: #{ x: 1, y: 0, z: 0 }, speed: 60 },
```

---

### OnRails

Starfox-style on-rails shooter. Camera follows a predefined spline path through the level. Player can dodge but cannot control forward movement.

**Controls:**
- Arrow keys / WASD: Dodge left/right/up/down relative to path
- Space/Z: Fire (forward along path)
- X: Special weapon (bombs, etc.)

**Camera:**
- Position: Follows path spline with Catmull-Rom interpolation
- Rotation: Defined per path point (yaw, pitch)
- Player offset: Slight offset from camera for visibility

**Path definition:**
```rhai
path: [
    #{ pos: #{ x: 0, y: 100, z: 0 }, rot: #{ yaw: 0, pitch: 0 }, t: 0.0 },
    #{ pos: #{ x: 200, y: 100, z: -400 }, rot: #{ yaw: 15, pitch: -5 }, t: 0.5 },
    #{ pos: #{ x: 500, y: 100, z: -800 }, rot: #{ yaw: 0, pitch: 0 }, t: 1.0 },
],
```

**Use cases:** Corridor sequences, dramatic camera movements, set pieces

**Segment example:** `2_corridor.rhai`

---

### Turret

FPS-style aiming while on rails. Camera follows a path like OnRails, but player controls a crosshair with mouse aim instead of ship movement.

**Controls:**
- Mouse: Aim crosshair (yaw/pitch)
- Space/Z/Left click: Fire at crosshair
- X/Right click: Special weapon

**Camera:**
- Position: Follows path spline (same as OnRails)
- Rotation: Base from path, player adds aim offset
- Eye height: 1.7 units above path position

**Player state:**
- `position_3d`: Locked to path position
- `look_yaw`: Mouse X controls horizontal aim
- `look_pitch`: Mouse Y controls vertical aim (clamped to ~80 degrees)

**Use cases:** Stationary turret sections, boss fights with circling camera

**Segment examples:** `3_hangar.rhai`, `5_boss.rhai`

---

### FirstPerson

Full FPS movement. Player has complete control over position and view direction.

**Controls:**
- W/S: Move forward/backward
- A/D: Strafe left/right
- Mouse: Look around (yaw/pitch)
- Space/Z/Left click: Fire
- X/Right click: Special

**Camera:**
- Position: Player position + eye height (1.7 units)
- Direction: Player's `forward_3d()` vector
- No smoothing (direct 1:1 with player)

**Player state:**
- `position_3d`: Full 3D movement, clamped to bounds
- `look_yaw`: Mouse X (full 360 rotation)
- `look_pitch`: Mouse Y (clamped ±80 degrees)
- Initial yaw: PI (facing -Z, into the room)

**Movement calculation:**
```rust
let forward = player.forward_flat(); // XZ plane only
let right = player.right_3d();
let move_dir = forward * input.forward() - forward * input.backward()
             + right * input.right() - right * input.left();
player.position_3d += move_dir.normalize() * speed * DT;
```

**Use cases:** Indoor exploration, tight quarters combat

**Segment example:** `4_base.rhai`

---

### FreeFlight

Full 3D space flight with chase camera. Player controls a ship that can pitch, roll, and yaw freely.

**Controls:**
- W/S: Pitch up/down
- A/D: Roll left/right
- Q/E: Yaw left/right
- Arrow keys: Throttle and strafe
- Space/Z: Fire
- X: Special

**Camera:**
- Position: Behind and above player ship
- Target: Player position
- Smoothing: Lerp to avoid jarring movement

**Use cases:** Open space combat, dogfighting sections

**Not yet implemented in station world segments.**

---

## Mode Detection API

```rust
impl GameMode {
    /// Whether this mode uses 2D physics (XY plane only).
    pub fn is_2d(&self) -> bool {
        matches!(self, Self::SideScroll { .. })
    }

    /// Whether this mode is on rails (camera follows a path).
    pub fn is_on_rails(&self) -> bool {
        matches!(self, Self::OnRails { .. } | Self::Turret { .. })
    }

    /// Whether this is a first-person mode (mouse aiming).
    pub fn is_first_person(&self) -> bool {
        matches!(self, Self::FirstPerson | Self::Turret { .. })
    }

    /// Whether this allows full 3D movement.
    pub fn is_3d_free(&self) -> bool {
        matches!(self, Self::FreeFlight | Self::FirstPerson)
    }
}
```

## Input Mapping by Mode

The client creates different `PlayerInput` based on mode:

**Shmup modes** (SideScroll, OnRails, FreeFlight):
```rust
if self.up { input.set(PlayerInput::UP, true); }
if self.down { input.set(PlayerInput::DOWN, true); }
// No mouse delta
```

**FPS modes** (FirstPerson, Turret):
```rust
if self.up { input.set(PlayerInput::FORWARD, true); }
if self.down { input.set(PlayerInput::BACKWARD, true); }
input.set_mouse_delta(mouse_dx, mouse_dy);
```

## Station World Mode Progression

The station world demonstrates mode transitions:

```
1_approach (SideScroll) → Classic shmup, space exterior
       ↓
2_corridor (OnRails) → Starfox-style, enter station
       ↓
3_hangar (Turret) → FPS aim, on-rails camera
       ↓
4_base (FirstPerson) → Full FPS, explore base
       ↓
5_boss (Turret) → Boss arena, circling camera
```

Each transition clears enemies, resets player position, and reconfigures input handling automatically.
